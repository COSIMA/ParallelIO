{"name":"ParallelIO","tagline":"A high-level Parallel I/O Library for structured grid applications","body":"# ParallelIO\r\n\r\nA high-level Parallel I/O Library for structured grid applications\r\n\r\n## Dependencies\r\n\r\nPIO can use NetCDF (version 4.3.3+) and/or PnetCDF (version 1.6.0+) for I/O.\r\nIdeally, the NetCDF version should be built with MPI, which requires that it\r\nbe linked with an MPI-enabled version of HDF5.  Optionally, NetCDF can be \r\nbuilt with DAP support, which introduces a dependency on CURL.  Additionally,\r\nHDF5, itself, introduces dependencies on LIBZ and (optionally) SZIP.\r\n\r\n## Configuring with CMake\r\n\r\nTo configure the build, PIO requires CMake version 2.8.12+.  The typical\r\nconfiguration with CMake can be done as follows:\r\n\r\n```\r\nCC=mpicc FC=mpif90 cmake [-DOPTION1=value1 -DOPTION2=value2 ...] /path/to/pio/source\r\n```\r\n\r\nwhere `mpicc` and `mpif90` are the appropriate MPI-enabled compiler wrappers\r\nfor your system.\r\n\r\nThe `OPTIONS` section typically should consist of pointers to the install\r\nlocations for various dependencies, assuming these dependencies are not \r\nlocated in *canonical* search locations.  \r\n\r\nFor each dependency `XXX`, one can specify the location of its \r\ninstallation path with the CMake variable `XXX_PATH`.  If the `C` and\r\n`Fortran` libraries for the dependency are installed in different locations\r\n(such as can be done with NetCDF), then you can specify individually\r\n`XXX_C_PATH` and `XXX_Fortran_PATH`.  Hence, you can specify the locations\r\nof both NetCDF-C and NetCDF-Fortran, as well as PnetCDF, with the following\r\nCMake configuration line:\r\n\r\n```\r\nCC=mpicc FC=mpif90 cmake -DNetCDF_C_PATH=/path/to/netcdf-c \\\r\n                         -DNetCDF_Fortran_PATH=/path/to/netcdf-fortran \\\r\n                         -DPnetCDF_PATH=/path/to/pnetcdf \\\r\n                         /path/to/pio/source\r\n```\r\n\r\nThis works for the dependencies: `NetCDF`, `PnetCDF`, `HDF5`, `LIBZ`, `SZIP`.\r\n\r\n### Additional CMake Options\r\n\r\nAdditional configuration options can be specified on the command line.\r\n\r\nThe `PIO_ENABLE_TIMING` option can be set to `ON` or `OFF` to enable or\r\ndisable the use of GPTL timing in the PIO libraries.  This feature requires\r\nthe GPTL C library for the PIO `C` library and the GPTL Fortran library with\r\nthe `perf_mod.mod` and `perf_utils.mod` interface modules.  If these GPTL\r\nlibraries are already installed on the system, the user can point PIO to the\r\nlocation of these libraries with the `GPTL_PATH` variable (or, individually,\r\n`GPTL_C_PATH` and `GPTL_Fortran_Perf_PATH` variables).  However, if these\r\nGPTL libraries are not installed on the system, and GPTL cannot be found,\r\nthen PIO will build its own internal version of GPTL.  \r\n\r\nIf PnetCDF is not installed on the system, the user can disable its use by\r\nsetting `-DWITH_PNETCDF=OFF`.  This will disable the search for PnetCDF on the\r\nsystem and disable the use of PnetCDF from within PIO.\r\n\r\nIf the user wishes to disable the PIO tests, then the user can set the\r\nvariable `-DPIO_ENABLE_TESTS=OFF`.  This will entirely disable the CTest \r\ntesting suite, as well as remove all of the test build targets.\r\n\r\nIf you wish to install PIO in a safe location for use later with other\r\nsoftware, you may set the `CMAKE_INSTALL_PREFIX` variable to point to the\r\ndesired install location.\r\n\r\n## Building\r\n\r\nOnce you have successfully configured PIO with CMake in a build directory.\r\nFrom within the build directory, build PIO with:\r\n\r\n```\r\nmake\r\n```\r\n\r\nThis will build the `pioc` and `piof` libraries.\r\n\r\n## Testing\r\n\r\nIf you desire to do testing, and `PIO_ENABLE_TESTS=ON` (which is the default\r\nsetting), you may build the test executables with:\r\n\r\n```\r\nmake tests\r\n```\r\n\r\nOnce the tests have been built, you may run tests with:\r\n\r\n```\r\nctest\r\n```\r\n\r\nIf you have not run `make tests` before you run `ctest`, then you will see\r\nall of the tests fail.\r\n\r\nAlternatively, you may build the test executables and then run tests \r\nimmediately with:\r\n\r\n```\r\nmake check\r\n```\r\n\r\n(similar to the typical `make check` Autotools target).\r\n\r\n**NOTE:** It is important to note that these tests are designed to run in parallel.\r\nIf you are on one of the supported supercomputing platforms (i.e., NERSC, NWSC, ALCF, \r\netc.), then the `ctest` command will assume that the tests will be run in an appropriately\r\nconfigured and scheduled parallel job.  This can be done by requesting an interactive\r\nsession from the login nodes and then running `ctest` from within the interactive\r\nterminal.  Alternatively, this can be done by running the `ctest` command from a\r\njob submission script.  It is important to understand, however, that `ctest` itself\r\nwill preface all of the test executable commands with the appropriate `mpirun`/`mpiexec`/`runjob`/etc.\r\nHence, you should not further preface the `ctest` command with these MPI launchers.\r\n\r\n## Installing\r\n\r\nOnce you have built the PIO libraries, you may install them in the location\r\nspecified by the `CMAKE_INSTALL_PREFIX`.  To do this, simply type:\r\n\r\n```\r\nmake install\r\n```\r\n\r\nIf the internal GPTL libraries were built (because GPTL could not be found\r\nand the `PIO_ENABLE_TIMING` variable is set to `ON`), then these libraries\r\nwill be installed with PIO.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}