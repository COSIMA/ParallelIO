<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PIO: Writing Distributes Arrays into a Variable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PIO
   &#160;<span id="projectnumber">2.4.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Writing Distributes Arrays into a Variable</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8e6611243431101939c4dd4c991a7e0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#ga8e6611243431101939c4dd4c991a7e0b">PIOc_write_darray_multi</a> (int ncid, const int *varids, int ioid, int nvars, <a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a> arraylen, void *array, const int *frame, void **fillvalue, bool flushtodisk)</td></tr>
<tr class="memdesc:ga8e6611243431101939c4dd4c991a7e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one or more arrays with the same IO decomposition to the file.  <a href="#ga8e6611243431101939c4dd4c991a7e0b">More...</a><br /></td></tr>
<tr class="separator:ga8e6611243431101939c4dd4c991a7e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3e7daa32e4bcbd54a1afa2508ed5f4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#gab3e7daa32e4bcbd54a1afa2508ed5f4f">find_var_fillvalue</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, int varid, <a class="el" href="structvar__desc__t.html">var_desc_t</a> *vdesc)</td></tr>
<tr class="memdesc:gab3e7daa32e4bcbd54a1afa2508ed5f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the fillvalue that should be used for a variable.  <a href="#gab3e7daa32e4bcbd54a1afa2508ed5f4f">More...</a><br /></td></tr>
<tr class="separator:gab3e7daa32e4bcbd54a1afa2508ed5f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa40fae759a2a5e39cb7af9b6f024db8f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#gaa40fae759a2a5e39cb7af9b6f024db8f">PIOc_write_darray</a> (int ncid, int varid, int ioid, <a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a> arraylen, void *array, void *fillvalue)</td></tr>
<tr class="memdesc:gaa40fae759a2a5e39cb7af9b6f024db8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a distributed array to the output file.  <a href="#gaa40fae759a2a5e39cb7af9b6f024db8f">More...</a><br /></td></tr>
<tr class="separator:gaa40fae759a2a5e39cb7af9b6f024db8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d94571912fdbac7f55dac70418613fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#ga8d94571912fdbac7f55dac70418613fe">find_start_count</a> (int ndims, int fndims, <a class="el" href="structvar__desc__t.html">var_desc_t</a> *vdesc, <a class="el" href="structio__region.html">io_region</a> *region, const int *frame, size_t *start, size_t *count)</td></tr>
<tr class="memdesc:ga8d94571912fdbac7f55dac70418613fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill start/count arrays for <a class="el" href="group___p_i_o__write__darray__c.html#ga095e39ac8c9e4e8cdb23c0e401a8ec34" title="Write a set of one or more aggregated arrays to output file. ">write_darray_multi_par()</a>.  <a href="#ga8d94571912fdbac7f55dac70418613fe">More...</a><br /></td></tr>
<tr class="separator:ga8d94571912fdbac7f55dac70418613fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga095e39ac8c9e4e8cdb23c0e401a8ec34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#ga095e39ac8c9e4e8cdb23c0e401a8ec34">write_darray_multi_par</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, int nvars, int fndims, const int *varids, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, int fill, const int *frame)</td></tr>
<tr class="memdesc:ga095e39ac8c9e4e8cdb23c0e401a8ec34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a set of one or more aggregated arrays to output file.  <a href="#ga095e39ac8c9e4e8cdb23c0e401a8ec34">More...</a><br /></td></tr>
<tr class="separator:ga095e39ac8c9e4e8cdb23c0e401a8ec34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae16c81480e986ab1f684e1612c1035b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#gae16c81480e986ab1f684e1612c1035b6">send_all_start_count</a> (<a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *ios, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, <a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a> llen, int maxregions, int nvars, int fndims, size_t *tmp_start, size_t *tmp_count, void *iobuf)</td></tr>
<tr class="memdesc:gae16c81480e986ab1f684e1612c1035b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function called by IO tasks other than IO task 0 to send their tmp_start/tmp_count arrays to IO task 0.  <a href="#gae16c81480e986ab1f684e1612c1035b6">More...</a><br /></td></tr>
<tr class="separator:gae16c81480e986ab1f684e1612c1035b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8962adeb628369df663bb35eeb86bc4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#ga8962adeb628369df663bb35eeb86bc4f">recv_and_write_data</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, const int *varids, const int *frame, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, <a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a> llen, int maxregions, int nvars, int fndims, size_t *tmp_start, size_t *tmp_count, void *iobuf)</td></tr>
<tr class="memdesc:ga8962adeb628369df663bb35eeb86bc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an internal function that is run only on IO proc 0.  <a href="#ga8962adeb628369df663bb35eeb86bc4f">More...</a><br /></td></tr>
<tr class="separator:ga8962adeb628369df663bb35eeb86bc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41c45f0b205bcef5184404ac50567feb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#ga41c45f0b205bcef5184404ac50567feb">write_darray_multi_serial</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, int nvars, int fndims, const int *varids, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, int fill, const int *frame)</td></tr>
<tr class="memdesc:ga41c45f0b205bcef5184404ac50567feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a set of one or more aggregated arrays to output file in serial mode.  <a href="#ga41c45f0b205bcef5184404ac50567feb">More...</a><br /></td></tr>
<tr class="separator:ga41c45f0b205bcef5184404ac50567feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b614dbe44ee8bd3a113090ebc2c23fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#ga1b614dbe44ee8bd3a113090ebc2c23fd">flush_output_buffer</a> (<a class="el" href="structfile__desc__t.html">file_desc_t</a> *file, bool force, <a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a> addsize)</td></tr>
<tr class="memdesc:ga1b614dbe44ee8bd3a113090ebc2c23fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the output buffer.  <a href="#ga1b614dbe44ee8bd3a113090ebc2c23fd">More...</a><br /></td></tr>
<tr class="separator:ga1b614dbe44ee8bd3a113090ebc2c23fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35aea71e1d8cb61a1b6bffc6a15731af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#ga35aea71e1d8cb61a1b6bffc6a15731af">cn_buffer_report</a> (<a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *ios, bool collective)</td></tr>
<tr class="memdesc:ga35aea71e1d8cb61a1b6bffc6a15731af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out info about the buffer for debug purposes.  <a href="#ga35aea71e1d8cb61a1b6bffc6a15731af">More...</a><br /></td></tr>
<tr class="separator:ga35aea71e1d8cb61a1b6bffc6a15731af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae903eda0079d3e43184a1bfdb53a45ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#gae903eda0079d3e43184a1bfdb53a45ae">free_cn_buffer_pool</a> (<a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *ios)</td></tr>
<tr class="memdesc:gae903eda0079d3e43184a1bfdb53a45ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the buffer pool.  <a href="#gae903eda0079d3e43184a1bfdb53a45ae">More...</a><br /></td></tr>
<tr class="separator:gae903eda0079d3e43184a1bfdb53a45ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54bb852697cc62d54b7528bc4cee47b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#ga54bb852697cc62d54b7528bc4cee47b6">flush_buffer</a> (int ncid, <a class="el" href="structwmulti__buffer.html">wmulti_buffer</a> *wmb, bool flushtodisk)</td></tr>
<tr class="memdesc:ga54bb852697cc62d54b7528bc4cee47b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the buffer.  <a href="#ga54bb852697cc62d54b7528bc4cee47b6">More...</a><br /></td></tr>
<tr class="separator:ga54bb852697cc62d54b7528bc4cee47b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae50e94f14e3b81ed3c694993695619"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_i_o__write__darray__c.html#ga8ae50e94f14e3b81ed3c694993695619">pio_sorted_copy</a> (const void *array, void *sortedarray, <a class="el" href="structio__desc__t.html">io_desc_t</a> *iodesc, int nvars, int direction)</td></tr>
<tr class="memdesc:ga8ae50e94f14e3b81ed3c694993695619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the contents of an array.  <a href="#ga8ae50e94f14e3b81ed3c694993695619">More...</a><br /></td></tr>
<tr class="separator:ga8ae50e94f14e3b81ed3c694993695619"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga35aea71e1d8cb61a1b6bffc6a15731af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35aea71e1d8cb61a1b6bffc6a15731af">&#9670;&nbsp;</a></span>cn_buffer_report()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cn_buffer_report </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *&#160;</td>
          <td class="paramname"><em>ios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>collective</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print out info about the buffer for debug purposes. </p>
<p>This should only be called when logging is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ios</td><td>pointer to the IO system structure </td></tr>
    <tr><td class="paramname">collective</td><td>true if collective report is desired</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards </dd></dl>

</div>
</div>
<a id="ga8d94571912fdbac7f55dac70418613fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d94571912fdbac7f55dac70418613fe">&#9670;&nbsp;</a></span>find_start_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_start_count </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvar__desc__t.html">var_desc_t</a> *&#160;</td>
          <td class="paramname"><em>vdesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__region.html">io_region</a> *&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill start/count arrays for <a class="el" href="group___p_i_o__write__darray__c.html#ga095e39ac8c9e4e8cdb23c0e401a8ec34" title="Write a set of one or more aggregated arrays to output file. ">write_darray_multi_par()</a>. </p>
<p>This is an internal function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ndims</td><td>the number of dims in the decomposition. </td></tr>
    <tr><td class="paramname">fndims</td><td>the number of dims in the file. </td></tr>
    <tr><td class="paramname">vdesc</td><td>pointer to the <a class="el" href="structvar__desc__t.html" title="Variable description structure. ">var_desc_t</a> info. </td></tr>
    <tr><td class="paramname">region</td><td>pointer to a region. </td></tr>
    <tr><td class="paramname">frame</td><td>array of record values. </td></tr>
    <tr><td class="paramname">start</td><td>an already-allocated array which gets the start values. </td></tr>
    <tr><td class="paramname">count</td><td>an already-allocated array which gets the count values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ed Hartnett </dd></dl>

</div>
</div>
<a id="gab3e7daa32e4bcbd54a1afa2508ed5f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3e7daa32e4bcbd54a1afa2508ed5f4f">&#9670;&nbsp;</a></span>find_var_fillvalue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_var_fillvalue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvar__desc__t.html">var_desc_t</a> *&#160;</td>
          <td class="paramname"><em>vdesc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the fillvalue that should be used for a variable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Info about file we are writing to. </td></tr>
    <tr><td class="paramname">varid</td><td>the variable ID. </td></tr>
    <tr><td class="paramname">vdesc</td><td>pointer to <a class="el" href="structvar__desc__t.html" title="Variable description structure. ">var_desc_t</a> info for this var. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, non-zero error code for failure.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Ed Hartnett </dd></dl>

</div>
</div>
<a id="ga54bb852697cc62d54b7528bc4cee47b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54bb852697cc62d54b7528bc4cee47b6">&#9670;&nbsp;</a></span>flush_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flush_buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwmulti__buffer.html">wmulti_buffer</a> *&#160;</td>
          <td class="paramname"><em>wmb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushtodisk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>identifies the netCDF file. </td></tr>
    <tr><td class="paramname">wmb</td><td>pointer to the <a class="el" href="structwmulti__buffer.html" title="The multi buffer holds data from one or more variables. ">wmulti_buffer</a> structure. </td></tr>
    <tr><td class="paramname">flushtodisk</td><td>if true, then flush data to disk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a id="ga1b614dbe44ee8bd3a113090ebc2c23fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b614dbe44ee8bd3a113090ebc2c23fd">&#9670;&nbsp;</a></span>flush_output_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int flush_output_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a>&#160;</td>
          <td class="paramname"><em>addsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the output buffer. </p>
<p>This is only relevant for files opened with pnetcdf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to </td></tr>
    <tr><td class="paramname">force</td><td>true to force the flushing of the buffer </td></tr>
    <tr><td class="paramname">addsize</td><td>additional size to add to buffer (in bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a id="gae903eda0079d3e43184a1bfdb53a45ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae903eda0079d3e43184a1bfdb53a45ae">&#9670;&nbsp;</a></span>free_cn_buffer_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free_cn_buffer_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *&#160;</td>
          <td class="paramname"><em>ios</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the buffer pool. </p>
<p>If malloc is used (that is, PIO_USE_MALLOC is non zero), this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ios</td><td>pointer to the IO system structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards </dd></dl>

</div>
</div>
<a id="ga8ae50e94f14e3b81ed3c694993695619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae50e94f14e3b81ed3c694993695619">&#9670;&nbsp;</a></span>pio_sorted_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pio_sorted_copy </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>sortedarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the contents of an array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>pointer to the array </td></tr>
    <tr><td class="paramname">sortedarray</td><td>pointer that gets the sorted array. </td></tr>
    <tr><td class="paramname">iodesc</td><td>pointer to the iodesc. </td></tr>
    <tr><td class="paramname">nvars</td><td>number of variables. </td></tr>
    <tr><td class="paramname">direction</td><td>sort direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards </dd></dl>

</div>
</div>
<a id="gaa40fae759a2a5e39cb7af9b6f024db8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa40fae759a2a5e39cb7af9b6f024db8f">&#9670;&nbsp;</a></span>PIOc_write_darray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PIOc_write_darray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>varid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a>&#160;</td>
          <td class="paramname"><em>arraylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fillvalue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a distributed array to the output file. </p>
<p>This routine aggregates output on the compute nodes and only sends it to the IO nodes when the compute buffer is full or when a flush is triggered.</p>
<p>Internally, this function will: </p><ul>
<li>
Locate info about this file, decomposition, and variable. </li>
<li>
If we don't have a fillvalue for this variable, determine one and remember it for future calls. </li>
<li>
Initialize or find the multi_buffer for this record/var. </li>
<li>
Find out how much free space is available in the multi buffer and flush if needed. </li>
<li>
Store the new user data in the mutli buffer. </li>
<li>
If needed (only for subset rearranger), fill in gaps in data with fillvalue. </li>
<li>
Remember the frame value (i.e. record number) of this data if there is one. </li>
</ul>
<p>NOTE: The write multi buffer <a class="el" href="structwmulti__buffer.html" title="The multi buffer holds data from one or more variables. ">wmulti_buffer</a> is the cache on compute nodes that will collect and store multiple variables before sending them to the io nodes. Aggregating variables in this way leads to a considerable savings in communication expense. Variables in the wmb array must have the same decomposition and base data size and we also need to keep track of whether each is a recordvar (has an unlimited dimension) or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>the ncid of the open netCDF file. </td></tr>
    <tr><td class="paramname">varid</td><td>the ID of the variable that these data will be written to. </td></tr>
    <tr><td class="paramname">ioid</td><td>the I/O description ID as passed back by <a class="el" href="group___p_i_o__initdecomp__c.html#ga56c119d47d1082df044968f80acbe265" title="Initialize the decomposition used with distributed arrays. ">PIOc_InitDecomp()</a>. </td></tr>
    <tr><td class="paramname">arraylen</td><td>the length of the array to be written. This should be at least the length of the local component of the distrubited array. (Any values beyond length of the local component will be ignored.) </td></tr>
    <tr><td class="paramname">array</td><td>pointer to an array of length arraylen with the data to be written. This is a pointer to the distributed portion of the array that is on this task. </td></tr>
    <tr><td class="paramname">fillvalue</td><td>pointer to the fill value to be used for missing data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, non-zero error code for failure.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a id="ga8e6611243431101939c4dd4c991a7e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e6611243431101939c4dd4c991a7e0b">&#9670;&nbsp;</a></span>PIOc_write_darray_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PIOc_write_darray_multi </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ncid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>varids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a>&#160;</td>
          <td class="paramname"><em>arraylen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>fillvalue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flushtodisk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one or more arrays with the same IO decomposition to the file. </p>
<p>This funciton is similar to <a class="el" href="group___p_i_o__write__darray__c.html#gaa40fae759a2a5e39cb7af9b6f024db8f" title="Write a distributed array to the output file. ">PIOc_write_darray()</a>, but allows the caller to use their own data buffering (instead of using the buffering implemented in <a class="el" href="group___p_i_o__write__darray__c.html#gaa40fae759a2a5e39cb7af9b6f024db8f" title="Write a distributed array to the output file. ">PIOc_write_darray()</a>).</p>
<p>When the user calls <a class="el" href="group___p_i_o__write__darray__c.html#gaa40fae759a2a5e39cb7af9b6f024db8f" title="Write a distributed array to the output file. ">PIOc_write_darray()</a> one or more times, then PIO_write_darray_multi() will be called when the buffer is flushed.</p>
<p>Internally, this function will: </p><ul>
<li>
Find info about file, decomposition, and variable. </li>
<li>
Do a special flush for pnetcdf if needed. </li>
<li>
Allocates a buffer big enough to hold all the data in the multi-buffer, for all tasks. </li>
<li>
Calls <a class="el" href="pio__internal_8h.html#a2cf6663a5359e57a8e9afc9b9b25a3f3" title="Moves data from compute tasks to IO tasks. ">rearrange_comp2io()</a> to move data from compute to IO tasks. </li>
<li>
For parallel iotypes (pnetcdf and netCDF-4 parallel) call pio_write_darray_multi_nc(). </li>
<li>
For serial iotypes (netcdf classic and netCDF-4 serial) call <a class="el" href="group___p_i_o__write__darray__c.html#ga41c45f0b205bcef5184404ac50567feb" title="Write a set of one or more aggregated arrays to output file in serial mode. ">write_darray_multi_serial()</a>. </li>
<li>
For subset rearranger, create holegrid to write missing data. Then call pio_write_darray_multi_nc() or <a class="el" href="group___p_i_o__write__darray__c.html#ga41c45f0b205bcef5184404ac50567feb" title="Write a set of one or more aggregated arrays to output file in serial mode. ">write_darray_multi_serial()</a> to write the holegrid. </li>
<li>
Special buffer flush for pnetcdf. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ncid</td><td>identifies the netCDF file. </td></tr>
    <tr><td class="paramname">varids</td><td>an array of length nvars containing the variable ids to be written. </td></tr>
    <tr><td class="paramname">ioid</td><td>the I/O description ID as passed back by <a class="el" href="group___p_i_o__initdecomp__c.html#ga56c119d47d1082df044968f80acbe265" title="Initialize the decomposition used with distributed arrays. ">PIOc_InitDecomp()</a>. </td></tr>
    <tr><td class="paramname">nvars</td><td>the number of variables to be written with this call. </td></tr>
    <tr><td class="paramname">arraylen</td><td>the length of the array to be written. This is the length of the distrubited array. That is, the length of the portion of the data that is on the processor. The same arraylen is used for all variables in the call. </td></tr>
    <tr><td class="paramname">array</td><td>pointer to the data to be written. This is a pointer to an array of arrays with the distributed portion of the array that is on this processor. There are nvars arrays of data, and each array of data contains one record worth of data for that variable. </td></tr>
    <tr><td class="paramname">frame</td><td>an array of length nvars with the frame or record dimension for each of the nvars variables in IOBUF. NULL if this iodesc contains non-record vars. </td></tr>
    <tr><td class="paramname">fillvalue</td><td>pointer an array (of length nvars) of pointers to the fill value to be used for missing data. </td></tr>
    <tr><td class="paramname">flushtodisk</td><td>non-zero to cause buffers to be flushed to disk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a id="ga8962adeb628369df663bb35eeb86bc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8962adeb628369df663bb35eeb86bc4f">&#9670;&nbsp;</a></span>recv_and_write_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int recv_and_write_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>varids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>frame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a>&#160;</td>
          <td class="paramname"><em>llen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxregions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>iobuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an internal function that is run only on IO proc 0. </p>
<p>It receives data from all the other IO tasks, and write that data to disk. This is called from <a class="el" href="group___p_i_o__write__darray__c.html#ga41c45f0b205bcef5184404ac50567feb" title="Write a set of one or more aggregated arrays to output file in serial mode. ">write_darray_multi_serial()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to. </td></tr>
    <tr><td class="paramname">varids</td><td>an array of the variable ids to be written </td></tr>
    <tr><td class="paramname">frame</td><td>the record dimension for each of the nvars variables in iobuf. NULL if this iodesc contains non-record vars. </td></tr>
    <tr><td class="paramname">iodesc</td><td>pointer to the decomposition info. </td></tr>
    <tr><td class="paramname">llen</td><td>length of the iobuffer on this task for a single field. </td></tr>
    <tr><td class="paramname">maxregions</td><td>max number of blocks to be written from this iotask. </td></tr>
    <tr><td class="paramname">nvars</td><td>the number of variables to be written with this decomposition. </td></tr>
    <tr><td class="paramname">fndims</td><td>the number of dimensions in the file. </td></tr>
    <tr><td class="paramname">tmp_start</td><td>pointer to an already allocaed array of length fndims * maxregions. This array will get the start values for all regions. </td></tr>
    <tr><td class="paramname">tmp_count</td><td>pointer to an already allocaed array of length fndims * maxregions. This array will get the count values for all regions. </td></tr>
    <tr><td class="paramname">iobuf</td><td>the buffer to be written from this mpi task. May be null. for example we have 8 ionodes and a distributed array with global size 4, then at least 4 nodes will have a null iobuf. In practice the box rearranger trys to have at least blocksize bytes on each io task and so if the total number of bytes to write is less than blocksize*numiotasks then some iotasks will have a NULL iobuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a id="gae16c81480e986ab1f684e1612c1035b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae16c81480e986ab1f684e1612c1035b6">&#9670;&nbsp;</a></span>send_all_start_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int send_all_start_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structiosystem__desc__t.html">iosystem_desc_t</a> *&#160;</td>
          <td class="paramname"><em>ios</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pio_8h.html#a1225edb54e6d6de678bf675485549eb0">PIO_Offset</a>&#160;</td>
          <td class="paramname"><em>llen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxregions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>tmp_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>iobuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal function called by IO tasks other than IO task 0 to send their tmp_start/tmp_count arrays to IO task 0. </p>
<p>This is an internal function which is only called on io tasks other than IO task 0. It is called by <a class="el" href="group___p_i_o__write__darray__c.html#ga41c45f0b205bcef5184404ac50567feb" title="Write a set of one or more aggregated arrays to output file in serial mode. ">write_darray_multi_serial()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a id="ga095e39ac8c9e4e8cdb23c0e401a8ec34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga095e39ac8c9e4e8cdb23c0e401a8ec34">&#9670;&nbsp;</a></span>write_darray_multi_par()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_darray_multi_par </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>varids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a set of one or more aggregated arrays to output file. </p>
<p>This function is only used with parallel-netcdf and netcdf-4 parallel iotypes. Serial io types use <a class="el" href="group___p_i_o__write__darray__c.html#ga41c45f0b205bcef5184404ac50567feb" title="Write a set of one or more aggregated arrays to output file in serial mode. ">write_darray_multi_serial()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to </td></tr>
    <tr><td class="paramname">nvars</td><td>the number of variables to be written with this decomposition. </td></tr>
    <tr><td class="paramname">vid</td><td>an array of the variable ids to be written. </td></tr>
    <tr><td class="paramname">iodesc</td><td>pointer to the <a class="el" href="structio__desc__t.html" title="IO descriptor structure. ">io_desc_t</a> info. </td></tr>
    <tr><td class="paramname">fill</td><td>Non-zero if this write is fill data. </td></tr>
    <tr><td class="paramname">frame</td><td>the record dimension for each of the nvars variables in iobuf. NULL if this iodesc contains non-record vars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
<a id="ga41c45f0b205bcef5184404ac50567feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41c45f0b205bcef5184404ac50567feb">&#9670;&nbsp;</a></span>write_darray_multi_serial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int write_darray_multi_serial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfile__desc__t.html">file_desc_t</a> *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nvars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>varids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structio__desc__t.html">io_desc_t</a> *&#160;</td>
          <td class="paramname"><em>iodesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a set of one or more aggregated arrays to output file in serial mode. </p>
<p>This function is called for netCDF classic and netCDF-4 serial iotypes. Parallel iotypes use <a class="el" href="group___p_i_o__write__darray__c.html#ga095e39ac8c9e4e8cdb23c0e401a8ec34" title="Write a set of one or more aggregated arrays to output file. ">write_darray_multi_par()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>a pointer to the open file descriptor for the file that will be written to. </td></tr>
    <tr><td class="paramname">nvars</td><td>the number of variables to be written with this decomposition. </td></tr>
    <tr><td class="paramname">varids</td><td>an array of the variable ids to be written </td></tr>
    <tr><td class="paramname">iodesc</td><td>pointer to the decomposition info. </td></tr>
    <tr><td class="paramname">fill</td><td>Non-zero if this write is fill data. </td></tr>
    <tr><td class="paramname">frame</td><td>the record dimension for each of the nvars variables in iobuf. NULL if this iodesc contains non-record vars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 for success, error code otherwise.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Jim Edwards, Ed Hartnett </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 25 2019 08:15:39 for PIO by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
